import 'package:meta/meta.dart';

import 'extensions/vector2.dart';

/// A relative position inside some 2D object with a rectangular size or bounding
/// box.
///
/// In Components, the Anchor is where the component position is measured from.
/// For example, if a component position is (100, 100) the anchor reflects what
/// exact point of the component that is positioned at (100, 100), as a relative
/// fraction of the size of the object.
///
/// The "default" anchor in most cases is [topLeft].
///
/// The Anchor is represented by a fraction of the size (in each axis), where:
/// For the horizontal axis ([x]):
///  - `O` means the left edge
///  - `1` means the right edge
/// For the vertical axis ([y]):
///  - `O` means the top edge
///  - `1` means the bottom edge
@immutable
class Anchor {
  static const Anchor topLeft = Anchor(0.0, 0.0);
  static const Anchor topCenter = Anchor(0.5, 0.0);
  static const Anchor topRight = Anchor(1.0, 0.0);
  static const Anchor centerLeft = Anchor(0.0, 0.5);
  static const Anchor center = Anchor(0.5, 0.5);
  static const Anchor centerRight = Anchor(1.0, 0.5);
  static const Anchor bottomLeft = Anchor(0.0, 1.0);
  static const Anchor bottomCenter = Anchor(0.5, 1.0);
  static const Anchor bottomRight = Anchor(1.0, 1.0);

  /// The relative position in the horizontal axis with respect to the object's
  /// width.
  ///
  /// 0 means totally to the left (origin) and 1 means totally to the right (end).
  final double x;

  /// The relative position in the vertical axis with respect to the object's
  /// height.
  ///
  /// 0 means totally to the top (origin) and 1 means totally to the bottom (end).
  final double y;


  /// The relative coordinates [x] and [y] as a [Vector2].
  Vector2 toVector2() => Vector2(x, y);

  const Anchor(this.x, this.y);

  /// Returns the relative non-fractional coordinate that this [Anchor] represents
  /// in a rectangular form given its [absoluteCoordinates] and [size].
  Vector2 translate(Vector2 absoluteCoordinates, Vector2 size) {
    return absoluteCoordinates - (toVector2()..multiply(size));
  }

  /// Takes a [position] that is on this anchor and give back what it would be on
  /// [otherAnchor] with a [size].
  Vector2 toOtherAnchorPosition(
    Vector2 position,
    Anchor otherAnchor,
    Vector2 size,
  ) {
    return position + ((otherAnchor.toVector2() - toVector2())..multiply(size));
  }

  /// Serializes this [Anchor] into a [String].
  ///
  /// See also:
  /// * [valueOf] to deserialize an [Anchor] from a [String] generated by this method.
  String get name {
    return _valueNames[this] ?? 'Anchor($x, $y)';
  }

  /// Returns a string representation of this [Anchor].
  ///
  /// This is the same as `name` and should be used only for debugging or
  /// serialization.
  @override
  String toString() => name;

  // A definition of the serialized names for anchor generated on
  static final Map<Anchor, String> _valueNames = {
    topLeft: 'topLeft',
    topCenter: 'topCenter',
    topRight: 'topRight',
    centerLeft: 'centerLeft',
    center: 'center',
    centerRight: 'centerRight',
    bottomLeft: 'bottomLeft',
    bottomCenter: 'bottomCenter',
    bottomRight: 'bottomRight',
  };

  /// List of all predefined anchor values.
  static final List<Anchor> values = _valueNames.keys.toList();

  /// Deserializes an [Anchor] from a string [name] generated from [toString].
  ///
  /// This should only be used for serializable data (like JSON),
  /// used in the [toString] and [valueOf] methods.
  static Anchor valueOf(String name) {
    if (_valueNames.containsValue(name)) {
      return _valueNames.entries.singleWhere((e) => e.value == name).key;
    } else {
      final regexp = RegExp(r'^\Anchor\(([^,]+), ([^\)]+)\)');
      final matches = regexp.firstMatch(name)?.groups([1, 2]);
      assert(
        matches != null && matches.length == 2,
        'Bad anchor format: $name',
      );
      return Anchor(double.parse(matches![0]!), double.parse(matches[1]!));
    }
  }

  @override
  bool operator ==(Object other) {
    return other is Anchor && hashCode == other.hashCode;
  }

  @override
  int get hashCode => x.hashCode * 31 + y.hashCode;
}
